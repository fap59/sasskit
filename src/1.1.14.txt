import * as vscode from 'vscode';
import * as path from 'path';

let sassCache: {
    [filePath: string]: {
        variables: Set<string>;
        functions: Set<string>;
        mixins: Set<string>;
    }
} = {};

let isCacheReady = false;

export async function activate(context: vscode.ExtensionContext) {
    const statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 100);
    statusBarItem.text = '$(refresh) Sass Cache';
    statusBarItem.tooltip = 'Refresh Sass autocomplete cache';
    statusBarItem.command = 'extension.refreshSassCache';
    statusBarItem.show();
    context.subscriptions.push(statusBarItem);

    const refreshCommand = vscode.commands.registerCommand('extension.refreshSassCache', async () => {
        await refreshSassCache();
        vscode.window.setStatusBarMessage('Sass Kit: Cache refreshed ✔️', 3000);
    });
    context.subscriptions.push(refreshCommand);

    const insertUseCommand = vscode.commands.registerCommand('extension.insertUseAtTop', async (document: vscode.TextDocument, relPath: string) => {
        const edit = new vscode.WorkspaceEdit();
    
        const isSassFile = document.fileName.endsWith('.sass');
        const useStatement = `@use "${relPath}" as *${isSassFile ? '' : ';'}\n`;
    
        const alreadyUsed = document.getText().includes(useStatement.trim());
        if (alreadyUsed) return;
    
        const firstLine = document.lineAt(0);
        edit.insert(document.uri, firstLine.range.start, useStatement);
        await vscode.workspace.applyEdit(edit);
    });
    context.subscriptions.push(insertUseCommand);

    const provider = new SassCompletionProvider(() => isCacheReady);
    context.subscriptions.push(
        vscode.languages.registerCompletionItemProvider(['scss', 'sass'], provider, '$', '@')
    );

    await refreshSassCache();
}

async function refreshSassCache() {
    sassCache = {};
    const sassFiles = await vscode.workspace.findFiles('**/*.{sass,scss}');

    for (const fileUri of sassFiles) {
        const fileText = (await vscode.workspace.openTextDocument(fileUri)).getText();
        const variables = [...new Set(fileText.match(/\$[a-zA-Z0-9-_]+/g) || [])];
        const functions = [...fileText.matchAll(/@function\s+([a-zA-Z0-9-_]+)/g)].map(m => m[1]);
        const mixins = [...fileText.matchAll(/@mixin\s+([a-zA-Z0-9-_]+)/g)].map(m => m[1]);

        sassCache[fileUri.fsPath] = {
            variables: new Set(variables),
            functions: new Set(functions),
            mixins: new Set(mixins)
        };
    }

    isCacheReady = true;
}

class SassCompletionProvider implements vscode.CompletionItemProvider {
    private isEnabled: () => boolean;

    constructor(isEnabled: () => boolean) {
        this.isEnabled = isEnabled;
    }

    async provideCompletionItems(document: vscode.TextDocument, position: vscode.Position) {
        if (!this.isEnabled()) return [];

        const completions: vscode.CompletionItem[] = [];
        const currentDir = path.dirname(document.uri.fsPath);

        for (const filePath in sassCache) {
            const relPath = path.relative(currentDir, filePath)
                .replace(/\\/g, '/')
                .replace(/\.(scss|sass)$/, '');

            const data = sassCache[filePath];

            for (const variable of data.variables) {
                const item = new vscode.CompletionItem(variable, vscode.CompletionItemKind.Variable);
                item.insertText = variable;
                item.detail = `From: ${relPath}`;
                item.command = {
                    command: 'extension.insertUseAtTop',
                    title: 'Insert @use',
                    arguments: [document, relPath]
                };
                completions.push(item);
            }

            for (const func of data.functions) {
                const item = new vscode.CompletionItem(func, vscode.CompletionItemKind.Function);
                item.insertText = `${func}()`;
                item.detail = `From: ${relPath}`;
                item.command = {
                    command: 'extension.insertUseAtTop',
                    title: 'Insert @use',
                    arguments: [document, relPath]
                };
                completions.push(item);
            }

            for (const mixin of data.mixins) {
                const item = new vscode.CompletionItem(mixin, vscode.CompletionItemKind.Method);
                item.insertText = `@include ${mixin}();`;
                item.detail = `From: ${relPath}`;
                item.command = {
                    command: 'extension.insertUseAtTop',
                    title: 'Insert @use',
                    arguments: [document, relPath]
                };
                completions.push(item);
            }
        }

        return completions;
    }
}

export function deactivate() {}